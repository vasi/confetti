<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Canvas test</title>
  <style type="text/css">
body { margin: 0; padding: 0; height: 100%; overflow: hidden; }
  </style>
  <script type="text/javascript">
(function() {
  function Confetti(style, x) {
    this.style = style;
    this.y = 0;
    this.x = x;
  }
  Confetti.prototype = {
    paint: function(a) {
      a.fillBox(this.x, this.y, this.style);
    },
    clear: function(a) {
      a.clearBox(this.x, this.y);
    },
  };

  function Shower(colorFactory, standoff, duration, intensity, x, w) {
    this.colorFactory = colorFactory;
    this.standoff = standoff;
    this.duration = duration;
    this.intensity = intensity;
    this.x = x;
    this.w = w;

    this.fractional = 0;
  }
  Shower.prototype = {
    addConfetti: function(arena) {
      if (this.standoff > 0) {
        --this.standoff;
        return true;
      }

      this.fractional += this.intensity;
      while (this.fractional >= 1) {
        --this.fractional;
        var x;
        for (var i = 0; i < this.w; ++i) { // try to find a column with room
          x = this.x + arena.rand(this.w);
          if (!arena.get(x, 0))
            break;
        }
        if (arena.get(x, 0)) // couldn't find room, just skip it
          continue;

        arena.addConfetti(new Confetti(this.colorFactory(x), x));
      }

      return this.duration-- > 0;
    },
    hasRoom: function(arena) {
      for (var i = 0; i <= this.w; ++i) {
        if (!arena.get(this.x + i, 0))
          return true;
      }
      return false;
    }
  };

  function Arena(id) {
    var canvas = document.getElementById(id);
    this.context = canvas.getContext("2d");
    this.boxSize = 1;
    this.colorRE = /^\#(..)(..)(..)$/;
    this.background = "black";

    this.width = Math.floor(canvas.width / this.boxSize);
    this.height = Math.floor(canvas.height / this.boxSize);
    this.boxes = new Array(this.width * this.height);

    this.confetti = [];
    this.showers = [];

    this.clear();
    this.addBlocks();

	this.intervalID = null;
	var self = this;
	canvas.addEventListener('click', function(e) {
		if (self.intervalID) {
			window.clearInterval(self.intervalID);
			self.intervalID = null;
		} else {
			self.animate();
		}
	}, false);

    this.animate();
  }
  Arena.prototype = {
    clear: function() {
      this.context.fillStyle = this.background;
      this.context.fillRect(0, 0, this.context.canvas.width,
        this.context.canvas.height);
    },
    fillBox: function(x, y, style) {
      this.context.fillStyle = style;
      this.context.fillRect(x * this.boxSize, y * this.boxSize,
        this.boxSize, this.boxSize);
    },
    clearBox: function(x, y) {
      this.fillBox(x, y, this.background);
    },

    animate: function() {
      var interval = 30;
      var arena = this;
      this.intervalID = window.setInterval(function() { arena.frame(); }, interval);
    },

    rand: function(i) {
      return Math.floor(Math.random() * i);
    },

    index: function(x, y) {
      return y * this.width + x;
    },
    get: function(x, y) {
      return this.boxes[this.index(x, y)];
    },
    set: function(x, y, c) {
      this.boxes[this.index(x, y)] = c;
    },
    moveConfetti: function(c, x, y) {
      c.clear(this);
      this.set(c.x, c.y, null);
      c.x = x;
      c.y = y;
      this.set(x, y, c);
      c.paint(this);
    },
    addConfetti: function(c) {
      this.set(c.x, 0, c);
      c.paint(this);
      this.confetti.push(c);
    },

    trySideways: function(c, dir) {
      var x = c.x + dir;
      if (x < 0 || x >= this.width)
        return false;
      if (this.get(x, c.y) || this.get(x, c.y + 1))
        return false;
      this.moveConfetti(c, x, c.y + 1);
      return true;
    },
    confettiFrame: function() {
      var next = [];

      for (var i in this.confetti) {
        var c = this.confetti[i];
        var stopped = false;

        if (c.y >= this.height - 1) {
          continue;
        } else if (!this.get(c.x, c.y + 1)) {
          this.moveConfetti(c, c.x, c.y + 1);
        } else {
          var dir = 2 * this.rand(2) - 1; // -1 or 1
          if (!this.trySideways(c, dir) && !this.trySideways(c, -dir))
            stopped = true;
        }

        if (!stopped)
          next.push(c);
      }
      this.confetti = next;
    },

    // Make a color a bit lighter or darker
    nudgeColor: function(style) {
      // Get serialization
      this.context.fillStyle = style;
      style = this.context.fillStyle;

      var nudge = 20; // percent
      var scale = 1 + (-nudge + this.rand(2 * nudge + 1)) / 100;

      var result = '#';
      match = this.colorRE.exec(style);
      for (var i = 0; i < 3; ++i) {
        var hex = match[i + 1];
        var v = Math.round(scale * parseInt(hex, 16));
        if (v < 0) v = 0;
        if (v > 255) v = 255;

        hex = v.toString(16);
        if (hex.length < 2)
          result += '0';
        result += hex;
      }
      return result;
    },
    nudgeColorFactory: function() {
      var colors = ["white", "lime", "red", "yellow", "aqua", "fuchsia",
         "#39F", // blue
         "#F93", // orange
      ];
      var color = colors[this.rand(colors.length)];
      var arena = this;
      return function(x) {
        return arena.nudgeColor(color);
      };
    },
    hsv: function(h) {
      // given zero hue of color, and a hue, return color intensity at that hue
      function c(z, h) {
        var d = h - z;
        d = d - Math.floor(d);
        var v = 0;
        if (d < 1/6) v = 6*d;
        else if (d < 1/2) v = 1;
        else if (d < 2/3) v = 4 - 6*d;
        v = Math.round(255 * v);
        var x = v.toString(16);
        if (x.length < 2) return '0' + x;
        return x;
      }
      return '#' + c(2/3, h) + c(0, h) + c(1/3, h);
    },
    rainbowColorFactory: function() {
      var arena = this;
      var cache = [];
      return function(x) {
        if (cache[x]) return cache[x];
        var h = x / arena.width;
        var c = arena.hsv(2*h + 5/6); // root is magenta
        return (cache[x] = c);
      }
    },
    rotateColorFactory: function() {
      if (!this.hasOwnProperty("count")) {
        this.count = 0;
      }
      var arena = this;
      return function(x) {
        ++arena.count;
        return arena.hsv(5/6 + arena.count / (600 * 1000));
      };
    },
    colorFactory: function() {
      return this.rotateColorFactory();
    },
    createShower: function(frac) {
      //var standoff = 20, duration = 400, intensity = 0.4, overlap = -100;
      var standoff = 100, duration = 500, intensity = 0.5, overlap = 40;
	    var maxWidth = 80;
      var w = Math.floor(Math.min(this.width / 2, maxWidth));

      // Allow a shower to overlap the side, so we're not too middle-biased
      var x = -overlap + this.rand(this.width - w + 2 * overlap);
      w = Math.min(w, this.width - x);
      x = Math.max(x, 0);

      return new Shower(this.colorFactory(),
        standoff, duration * frac, intensity, x, w);
    },
    showerConfetti: function() {
      var count = 1;

      while (this.showers.length < count) {
        var s = this.createShower((this.showers.length + 1) / count);
        if (s.hasRoom(this))
          this.showers.push(s);
      }

      var next = [];
      for (var i = 0; i < this.showers.length; ++i) {
        var s = this.showers[i];
        if (s.addConfetti(this))
          next.push(s);
      }
      this.showers = next;
    },

    addBlocks: function() {
      var block = "block", style = "gray";
      var height = 7, vsep = 13, vlimit = 30;
      var margin = 0, sep = 5, min = 12, max = 25;
      //vsep = 19; sep = 9; max = 60; min = 10;
      vsep = 18; sep = 11; max = 48; min = 10;

      var top, bottom = 10; // top margin
      while (true) {
        top = bottom + vsep;
        var bottom = top + height;
        if (this.height - bottom < vlimit)
          break; // Don't get too close to bottom

        // Find appropriate horiz spaces
        var space = this.width - 2 * margin, blocks = [];
        while (true) {
          var b = min + this.rand(max - min);
          if (b > space)
            break;
          if (blocks.length != 0)
            space -= sep;
          blocks.push(b);
          space -= b;
        }

        // Build blocks
        var x = margin;
        while (blocks.length > 0) {
          var b = blocks.shift();

          // Draw the block
          for (var i = x; i < x + b; ++i) {
            for (var j = top; j < bottom; ++j) {
              this.set(i, j, block);
              this.fillBox(i, j, style);
            }
          }

          // Justify blocks, by using extra space in between
          var just = blocks.length > 0 ? Math.floor(space / blocks.length) : 0;
          space -= just;
          x += b + sep + just;
        }
      }
    },

    frame: function() {
      var skip = 6;
      for (var i = 0; i <= skip; ++i) {
        this.confettiFrame();
        this.showerConfetti();
      }
    },

  };

  window.onload = function() {
    new Arena("canvas");
  };
}());
  </script>
</head>
<body>
  <canvas id="canvas" width="1280" height="798"></canvas>
</body>
</html>
